GRID_SIZE = 16

type Position = x Int y Int

-- A mouse click is a position that might occur
type Click = x Int y Int

-- click is an external time-varying value
external click : Click | Nothing

type Particle = particle Position #save

particles : List Particle
init particles = []
next particles = if occured click
                 then particles :: particleGen (1, 1)
                 else map nextParticle particles

-- Lifted (automatically)
nparticles = length particles

-- A position is free iff there
isFree : Position -> Bool
isFree position = length(filter (\particle -> particle.positon == position) particles) == 0

-- !! particles.position (above and below) is not valid Elm, should it be valid Autumn?

isWithinBounds : Position -> Bool
isWithinBounds position = position.x >= 0 && position.x < GRID_SIZE && position.y >= 0 and position.y < GRID_SIZE

adjacentPositions : Position -> List
adjacentPositions position = 
  let
    x = position.x
    y = position.y
    positions = filter isWithinBounds [Position (x+1) y, Position (x-1) y, Position x (y+1), Position x (y-1)]
  in
  positions

-- At every time step, look for a free space around me and try to move into it
nextParticle : Particle -> Particle #update
nextParticle particle =
  let
    freePositions = filter isfree (adjacentPositions particle.position)
  in
    case freePositions
      [] -> particle
      _ -> Particle (uniformChoice freePositions)  -- !! this uniformChoice is suepect, need to decide on probabilities

particleGen : Position -> Particle #new
particleGen initPosition = Particle initPosition