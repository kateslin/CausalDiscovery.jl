(program
  (: GRID_SIZE Int)
  (= GRID_SIZE 16)

  (type alias Position ((: x Int) (: y Int)))
  (type alias Particle ((: position Position)))

  (external (: click Click))

  (: particles (List Particle))
  (= particles (initnext (list) (if (occurred click) 
                               then (push! (prev particles) (particleGen (Position 1 1))) 
                               else (map nextParticle (prev particles)))))
  (: nparticles Int)
  (= nparticles (length particles))
  
  (: isFree (-> Position Bool))
  (= isFree (fn (position) 
                (== (length (filter (--> particle (== (.. particle position) position)) (prev particles))) 0)))

  (: isWithinBounds (-> Position Bool))
  (= isWithinBounds (fn (position) 
                        (& (>= (.. position x) 0) (& (< (.. position x) GRID_SIZE) (& (>= (.. position y) 0) (< (.. position y) GRID_SIZE))))))
  
  (: adjacentPositions (-> Position (List Position)))
  (= adjacentPositions (fn (position) 
                           (let ((= x (.. position x)) 
                                 (= y (.. position y)) 
                                 (= positions (filter isWithinBounds (list (Position (+ x 1) y) (Position (- x 1) y) (Position x (+ y 1)) (Position x (- y 1))))))
                                positions)))

  (: nextParticle (-> Particle Particle))
  (= nextParticle (fn (particle) 
                      (let ((= freePositions (filter isFree (adjacentPositions (.. particle position))))) 
                           (case freePositions
                                (=> (list) particle)
                                (=> _ (Particle (uniformChoice freePositions)))))))

  (: particleGen (-> Position Particle))
  (= particleGen (fn (initPosition) (Particle initPosition)))
)

(program
  (= GRID_SIZE 16)

  (object Particle (Cell 0 0 "blue"))
	
  (: particles (List Particle))
  (= particles (initnext 
                  (list) 
				          (updateObj (prev particles) (--> obj (Particle (uniformChoice (adjPositions (.. obj origin))))))))	
  
  (on click (= particles (addObj (prev particles) (Particle (Position (.. click x) (.. click y))))))
)

(program
  (= GRID_SIZE 16)
  
  (object Ant (Cell 0 0 "gray"))
  (object Food (Cell 0 0 "red"))

  (: ants (List Ant))
	(= ants (initnext (map Ant (randomPositions GRID_SIZE 6)) 
										(updateObj (prev ants) nextAnt)))

  (: foods (List Food))
	(= foods (initnext (list) 
										 (updateObj (prev foods) (--> obj (if (== (distance obj (closest obj Ant)) 0)
																						 	         then (removeObj obj)
																							         else obj)))))

	(on click (= foods (addObj (prev foods) (map Food (randomPositions GRID_SIZE 4)))))

  (: nextAnt (-> Ant Ant))
  (= nextAnt (fn (ant) (move ant (unitVector ant (closest ant Food)))))
)

(program
  (= GRID_SIZE 10)
  (= background "black")

  (object Light (: on Bool) (Cell 0 0 (if on then "yellow" else "black")))

  (: lights (List Light))
  (= lights (mapPositions Light GRID_SIZE (--> pos (== (.. pos x) (.. pos y))) false))
  (on click (= lights (if (== (.. click x) (.. click y))
                       then (updateObj (prev lights) (--> obj (updateObj obj "on" (! (.. obj on))))) 
                       else (prev lights))))
)

(program
  (= GRID_SIZE 16)
  
  (object Magnet (list (Cell 0 0 "red") (Cell 0 1 "blue")))
  
  (: fixedMagnet Magnet)
  (= fixedMagnet (Magnet (Position 7 8)))

  (: mobileMagnet Magnet)
  (= mobileMagnet (Magnet (Position 4 7)))

  (on click (= mobileMagnet (updateMagnet (rotate mobileMagnet) mobileMagnet fixedMagnet attractVectors)))
  (on left (= mobileMagnet (updateMagnet (move mobileMagnet -1 0) mobileMagnet fixedMagnet attractVectors)))
  (on right (= mobileMagnet (updateMagnet (move mobileMagnet 1 0) mobileMagnet fixedMagnet attractVectors)))
  (on up (= mobileMagnet (updateMagnet (move mobileMagnet 0 -1) mobileMagnet fixedMagnet attractVectors)))
  (on down (= mobileMagnet (updateMagnet (move mobileMagnet 0 1) mobileMagnet fixedMagnet attractVectors)))

  (= invalid (fn (magnet1 magnet2) 
                 (| (adjacent (posPole magnet1) (posPole magnet2)) 
                    (adjacent (negPole magnet1) (negPole magnet2)))))
  
  (= updateMagnet (fn (interMagnet mobMagnet fixedMagnet attractVectors) 
                      (if (invalid interMagnet fixedMagnet) 
                      then mobMagnet 
                      else (let ((= disp1 (displacement (posPole interMagnet) (negPole fixedMagnet)))
                                 (= disp2 (displacement (negPole interMagnet) (posPole fixedMagnet)))
                                 (if (in disp1 attractVectors) 
                                 then (move interMagnet (unitVector disp1)) 
                                 else (if (in disp2 attractVectors) 
                                       then (move interMagnet (unitVector disp2)) 
                                       else interMagnet)))))))

  (= posPole (fn (magnet) (move (.. magnet origin) (first (.. magnet render)))))  
  (= negPole (fn (magnet) (move (.. magnet origin) (last (.. magnet render)))))

  (= attractVectors (list (Position 0 2) (Position 2 0) (Position -2 0) (Position 0 -2)))
)

(program
  (= GRID_SIZE 16)

  (object Button (: color String) (Cell 0 0 color))
  (object Vessel (Cell 0 0 "purple"))
  (object Plug (Cell 0 0 "orange"))
  (object Water (Cell 0 0 "blue"))

  (: vesselButton Button)
  (= vesselButton (Button "purple" (Position 2 0)))
  (: plugButton Button)
  (= plugButton (Button "orange" (Position 5 0)))
  (: waterButton Button)
  (= waterButton (Button "blue" (Position 8 0)))
  (: removeButton Button)
  (= removeButton (Button "black" (Position 11 0)))
  (: clearButton Button)
  (= clearButton (Button "red" (Position 14 0)))

  (: vessels (List Vessel))
  (= vessels (initnext (list) (prev vessels)))
  (: plugs (List Plug))
  (= plugs (initnext (list) (prev plugs)))
  (: water (List Water))
  (= water (initnext (list) (updateObj (prev water) nextLiquid)))

  (= currentParticle (initnext "vessel" (prev currentParticle)))

  (on click (if (isFree (Position (.. click x) (.. click y))) 
             then (if (== currentParticle "vessel") 
                   then (= vessels (addObj (prev vessels) (Vessel (Position (.. click x) (.. click y))))) 
                   else (if (== currentParticle "plug") 
                         then (= plugs (addObj (prev plugs) (Plug (Position (.. click x) (.. click y))))) 
                         else (= water (addObj (prev water) (Water (Position (.. click x) (.. click y)))))))
              else (= water (prev water))))

  (on (clicked vesselButton) (= currentParticle "vessel"))
  (on (clicked plugButton) (= currentParticle "plug"))
  (on (clicked waterButton) (= currentParticle "water"))
  (on (clicked removeButton) (= plugs (list)))
  (on (clicked clearButton) (let ((= vessels (list)) (= plugs (list)) (= water (list)))))  
)

(program
  (= GRID_SIZE 16)
  (object CelestialBody (: day Bool) (list (Cell 0 0 (if day then "gold" else "gray"))
                                           (Cell 0 1 (if day then "gold" else "gray"))
                                           (Cell 1 0 (if day then "gold" else "gray"))
                                           (Cell 1 1 (if day then "gold" else "gray"))))
  (object Cloud (list (Cell -1 0 "gray")
                      (Cell 0 0 "gray")
                      (Cell 1 0 "gray")))
  
  (object Water (: liquid Bool) (Cell 0 0 (if liquid then "blue" else "lightblue")))
  
  (: celestialBody CelestialBody)
  (= celestialBody (initnext (CelestialBody true (Position 0 0)) (prev celestialBody)))

  (: cloud Cloud)
  (= cloud (initnext (Cloud (Position 8 0)) (prev cloud)))
  
  (: water (List Water))
  (= water (initnext (list) (updateObj (prev water) nextWater)))
  
  (on left (= cloud (nextCloud cloud (Position -1 0))))

  (on right (= cloud (nextCloud cloud (Position 1 0))))

  (on down (= water (addObj water (Water 
                                    (.. celestialBody day) 
                                    (move (.. cloud origin) (Position 0 1))))))
  
  (on click (let ((= celestialBody (updateObj celestialBody "day" (! (.. celestialBody day))))
                  (= water (updateObj water (--> drop (updateObj drop "liquid" (! (.. drop liquid)))))))))

  (= nextWater (fn (drop) 
                   (if (.. drop liquid)
                    then (nextLiquid drop)
                    else (nextSolid drop))))
  
  (= nextCloud (fn (cloud position)
                   (if (isWithinBounds (move cloud position)) 
                    then (move cloud position)
                    else cloud)))
)

(program
  (= GRID_SIZE 16)
  
  (object Tetris (: shape (List Cell)) shape)

  (: blocks (List Tetris))
  (= blocks (initnext (list) (nextBlocks (prev blocks) activeTetris)))
  
  (: activeTetris Tetris)
  (= activeTetris (initnext (Tetris (list (Cell 0 0 "blue") (Cell 0 1 "blue") (Cell 0 2 "blue") (Cell 1 2 "blue")) 
                                    (uniformChoice (list (Position 4 0) (Position 7 0) (Position 10 0))))
                            (nextTetris activeTetris)))
  
  (on up (= activeTetris (rotateNoCollision activeTetris)))
  (on left (= activeTetris (moveNoCollision activeTetris (Position -1 0))))
  (on right (= activeTetris (moveNoCollision activeTetris (Position 1 0))))
  
  (= nextTetris (fn (tetris) 
                    (if (== (.. (.. (nextSolid tetris) origin) y) (.. (.. tetris origin) y)) 
                    then (Tetris (uniformChoice (list (list (Cell 0 0 "blue") (Cell 0 1 "blue") (Cell 0 2 "blue") (Cell 1 2 "blue"))
                                                      (list (Cell -1 0 "pink") (Cell 0 0 "pink") (Cell 0 1 "pink") (Cell 1 0 "pink"))
                                                      (list (Cell 0 0 "orange") (Cell 0 1 "orange") (Cell 1 0 "orange") (Cell 1 1 "orange"))
                                                      (list (Cell 0 0 "limegreen") (Cell 0 1 "limegreen") (Cell 1 1 "limegreen") (Cell 1 2 "limegreen")))) 
                                  (uniformChoice (list (Position 4 0) (Position 7 0) (Position 10 0)))) 
                    else (nextSolid tetris))))

  (= nextBlocks (fn (blocks tetris) 
                    (if (== (.. (.. (nextSolid tetris) origin) y) (.. (.. tetris origin) y)) 
                    then (addObj blocks tetris) 
                    else blocks)))  
)

# invalid condition syntax
# gravity field
# 