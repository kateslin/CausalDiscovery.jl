include "autumnStandardLibrary.sk";

// global variables
int GRID_SIZE = 4; // final
int ARR_BND = 10; // final
int uniformChoiceCounter = 0;

/* ----- BEGIN FULL PARTICLES EXAMPLE -----*/

struct State {
	int time;
	Click[ARR_BND] clickHistory;
	Particle[ARR_BND][ARR_BND] particlesHistory;
	Scene scene;
}

State init() {
	int time = 0;
	Particle[ARR_BND] particles;
	
	State state = new State();
	state.time = time;
	state.clickHistory[time] = null;
	state.particlesHistory[time] = particles;
	state.scene = new Scene(objects=particles, background="transparent");
	return state;
}

State next(State state, Click click) {
  Particle[ARR_BND] particles = state.particlesHistory[state.time];
	
	if (click != null) {
		particles = addObj(particles, particle(click.position)); // hole 1
	}
	
	if (click == null) {
		particles = updateObjArray(particles, (obj) -> (particle(uniformChoice(uniformChoiceCounter, adjPositions(GRID_SIZE, obj.origin))))); // hole 2
	}
	
	state.time = state.time + 1;
	state.clickHistory[state.time] = click;
	state.particlesHistory[state.time] = particles;
	state.scene = new Scene(objects=particles, background="transparent");
	return state;
}

/* ----- END FULL PARTICLES EXAMPLE -----*/

/* ----- UNIFORM CHOICE UTIL FUNC ----- */
Position uniformChoice(ref int counter, Position[ARR_BND] positions) {
  Position position;
  if (positions[4] == null) {
    position = positions[counter % 3];
  } else {
    position = positions[counter % 4];
  }
  counter++;
  return position;
}

/* ----- BEGIN HARNESS SUITE ----- */
harness void addParticle1() {
  State state = init();	// time 0
  state = synthNext(state, new Click(position=new Position(x=1, y=1))); // time 1
	Cell[ARR_BND] renderedScene = renderScene(state.scene);
  assert renderedScene[0] != null;
  assert renderedScene[0].position.x == 1 && renderedScene[0].position.y == 1;
  
  state = synthNext(state, null); // time 2
  renderedScene = renderScene(state.scene);
  assert renderedScene[0] != null;
  assert renderedScene[0].position.x == 2 && renderedScene[0].position.y == 1;
  
  state = synthNext(state, null); // time 3
  renderedScene = renderScene(state.scene);
  assert renderedScene[0] != null;
  assert renderedScene[0].position.x == 1 && renderedScene[0].position.y == 1; 
}

harness void addParticle2() {
  State state = init();	
  state = synthNext(state, new Click(position=new Position(x=2, y=3)));
	Cell[ARR_BND] renderedScene = renderScene(state.scene);
  assert renderedScene[0] != null;
  assert renderedScene[0].position.x == 2 && renderedScene[0].position.y == 3;
}

/* ----- END HARNESS SUITE ------ */

/* ------ BEGIN INCOMPLETE FUNCTION ----- */

State synthNext(State state, Click click) {
	Particle[ARR_BND] particles = state.particlesHistory[state.time];
  
  minrepeat {
    if (genEvent(particles, click, null)) {
      particles = genParticleArray(particles, click, null);
    }
  }

  /*
  if (genEvent(particles, click, null)) {
		// particles = addObj($(Particle[ARR_BND]), particle(genPosition(particles, click)));
    particles = genParticleArray(particles, click, null);
    // particles = addObj(particles, particle(click.position));
	}
  */

  if (click == null) {
		particles = genParticleArray(particles, click, null);
    // particles = updateObjArray(particles, (obj) -> (particle(uniformChoice(uniformChoiceCounter, adjPositions(GRID_SIZE, obj.origin)))));
	}

  /*
	if (click != null) {
		// particles = addObj($(Particle[ARR_BND]), particle(genPosition(particles, click)));
    particles = genParticleArray(particles, click, null);
    // particles = addObj(particles, particle(click.position));
	}
	
	if (click == null) {
		particles = genParticleArray(particles, click, null);
    // particles = updateObjArray(particles, (obj) -> (particle(uniformChoice(uniformChoiceCounter, adjPositions(GRID_SIZE, obj.origin)))));
	}
  */
	
	state.time = state.time + 1;
	state.clickHistory[state.time] = click;
	state.particlesHistory[state.time] = particles;
	state.scene = new Scene(objects=particles, background="transparent");
	return state;
}

/* ----- END INCOMPLETE FUNCTION ------ */

  /* ----- BEGIN GENERATORS ----- */
  // generate non-functions
  // (Object, Object[], Click, Cell, Cell[], Position, Position[], Scene, Int/Bool/Char[]) 
  generator Particle genParticle(Particle[ARR_BND] particles, Click click, Particle particle) {
    // return genFunRetParticle(particles, click, particle);
    if (??) {
      return $(Particle);
    } else {
      return genFunRetParticle(particles, click, particle);
    }
  }

  generator Particle[ARR_BND] genParticleArray(Particle[ARR_BND] particles, Click click, Particle particle) {
    if (??) {
      return $(Particle[ARR_BND]);
    } else {
      return genFunRetParticleArray(particles, click, particle);
    }
  }

  generator Click genClick(Particle[ARR_BND] particles, Click click, Particle particle) {
    return $(Click);
  }

  generator Cell genCell(Particle[ARR_BND] particles, Click click, Particle particle) {
    return new Cell(position=genPosition(particles, click, particle), color=genCharArray(particles, click, particle));
    // if (??) {
    //   return $(Cell);
    // } else {
    //   return new Cell(position=new Position(x=genInt(particles, click), y=genInt(particles, click)), color=genCharArray(particles, click));
    // }
  }

  generator Cell[ARR_BND] genCellArray(Particle[ARR_BND] particles, Click click, Particle particle) {
    return genFunRetCellArray(particles, click, particle);
    // if (??) {
    //   return $(Cell[ARR_BND]);
    // } else {
    //   return genFunRetCellArray(particles, click);
    // }
  }

  generator Position genPosition(Particle[ARR_BND] particles, Click click, Particle particle) {
    if (??) {
      return genClick(particles, click, particle).position;
    } else {
      if (??) {
        return new Position(x=genInt(particles, click, particle), y=genInt(particles, click, particle));
      } else {
        if (??) {
          return genCell(particles, click, particle).position;
        } else {
          if (??) {
            return genParticle(particles, click, particle).origin;
          } else {
            return genFunRetPosition(particles, click, particle);
          }
        }
      }
    }
    // if (??) {
    //   return genClick(particles, click).position;
    // } else {
    //   if (??) {
    //     return new Position(x=genInt(particles, click), y=genInt(particles, click));
    //   } else {
    //     if (??) {
    //       return $(Position);
    //     } else {
    //       if (??) {
    //         return genCell(particles, click).position;
    //       } else {
    //         if (??) {
    //           return genParticle(particles, click).origin;
    //         } else {
    //           return genFunRetPosition(particles, click);
    //         }
    //       }
    //     }
    //   }
    // }
  }

  generator Position[ARR_BND] genPositionArray(Particle[ARR_BND] particles, Click click, Particle particle) {
    return genFunRetPositionArray(particles, click, particle);
    // if (??) {
    //   return $(Position[ARR_BND]);
    // } else {
    //   return genFunRetPositionArray(particles, click);
    // }
  }

  // generator Scene genScene(Particle[ARR_BND] particles, Click click) {
  //   return new Scene(objects=particles, background="transparent");
  //   //return {| $(Scene) | state.scene |};
  // }

  generator int genInt(Particle[ARR_BND] particles, Click click, Particle particle) {
    Position pos = genPosition(particles, click, particle);
    if (??) {
      return ??;
    } else {
      if (??) {
        return pos.x;
      } else {
        return pos.y;
      }
    }
    // return {| $(int) | pos.x | pos.y |};
  }

  generator bit genBit(Particle[ARR_BND] particles, Click click, Particle particle) {
    return genFunRetBit(particles, click, particle);
    // if (??) {
    //   return $(bit);
    // } else {
    //   return genFunRetBit(particles, click);
    // }
    // return {| $(bit) | genFunRetBit() |};
  }

  generator char[STR_BND] genCharArray(Particle[ARR_BND] particles, Click click, Particle particle) {
    return genCell(particles, click, particle).color;
    // if (??) {
    //   return $(char[STR_BND]);
    // } else {
    //   return genCell(particles, click).color;
    // }
  }

  // ----- generate function calls -----
  generator Particle genFunRetParticle(Particle[ARR_BND] particles, Click click, Particle particle) {
    return particle(genPosition(particles, click, particle));
  }

  generator Particle[ARR_BND] genFunRetParticleArray(Particle[ARR_BND] particles, Click click, Particle particle) {  
    Particle particle_ = genParticle(particles, click, particle);
    Particle[ARR_BND] particles1 = genParticleArray(particles, click, particle);
    Particle[ARR_BND] particles2 = genParticleArray(particles, click, particle);
    if (??) {
      return addObj(particles1, particle_); 
    } else {
      if (??) {
        return addObjs(particles1, particles2);
      } else {
        if (??) {
          return removeObjFromArray(particles1, particle_);
        } else {
          return updateObjArray(particles1, (obj) -> (genParticle(particles, click, obj)));
        }
      }
    }
  }

  generator Cell[ARR_BND] genFunRetCellArray(Particle[ARR_BND] particles, Click click, Particle particle) {
    return renderObj(genParticle(particles, click, particle));
    // return {| renderScene(genScene(particles, click)) | renderObj(genParticle(particles, click)) |};
  }

  generator bit genFunRetBit(Particle[ARR_BND] particles, Click click, Particle particle) {
    Click c = genClick(particles, click, particle);
    Position pos = genPosition(particles, click, particle);
    Particle particle_ = genParticle(particles, click, particle);
    Particle[ARR_BND] particles_ = genParticleArray(particles, click, particle);
    return occurred(click);
    // return {| occurred(c) | isWithinBoundsPosition(GRID_SIZE, pos) | isWithinBoundsObject(GRID_SIZE, particle_) | clickedObj(c, particle_) | clickedObjArray(c, particles_) | clickedPosition(c, pos) |};
  }

  generator Position[ARR_BND] genFunRetPositionArray(Particle[ARR_BND] particles, Click click, Particle particle) {
    return adjPositions(GRID_SIZE, genPosition(particles, click, particle));
  }

  generator Position genFunRetPosition(Particle[ARR_BND] particles, Click click, Particle particle) {
    return uniformChoice(uniformChoiceCounter, genPositionArray(particles, click, particle));
  }

  generator bit genEvent(Particle[ARR_BND] particles, Click click, Particle particle) {
    return genBit(particles, click, particle);
  }

  /* ----- END GENERATORS ----- */