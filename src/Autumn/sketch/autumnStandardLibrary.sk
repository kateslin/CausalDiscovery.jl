int ARR_BND = 10;
int STR_BND = 20;

// Particle struct
struct Particle extends Object {
  Position origin;
  bit alive;
  Cell[ARR_BND] render;	
}

Particle particle(Position origin) {
	return new Particle(origin=origin, alive=1, render={ new Cell(position=new Position(x=0,y=0), color="blue") });
}

// abstract type
struct Object {

}

struct Position {
	int x;
	int y;
}

struct Click {
	Position position;
}

struct Cell {
	Position position;
	char[STR_BND] color; 
}

struct Scene {
	Particle[ARR_BND] objects;
	char[STR_BND] background;
}

// render functions
Cell[ARR_BND] renderScene(Scene scene) {
  Cell[ARR_BND] cells;
  Cell[ARR_BND] objCells;
  int cellIndex = 0;

  for (int objIndex = 0; objIndex < ARR_BND; objIndex++) {
    Particle obj = scene.objects[objIndex];
    if (obj != null) {
      objCells = renderObj(obj);
      for (int objCellIndex = 0; objCellIndex < ARR_BND; objCellIndex++) {
        cells[cellIndex++] = objCells[objCellIndex];
      }
    }
  }
  return cells;
}

Cell[ARR_BND] renderObj(Particle object) {
  Cell[ARR_BND] cells;
  for (int i = 0; i < ARR_BND; i++) {
    Cell cell = object.render[i];
    if (cell != null) {
      cells[i] = new Cell(position=new Position(x=cell.position.x+object.origin.x,
                                                y=cell.position.y+object.origin.y),
                          color=cell.color);
    }
  }
  return cells;
}

// is within bounds
bit isWithinBoundsPosition(int gridSize, Position position) {
  int num = gridSize * position.x + position.y;
  if (num >= 0 && num < gridSize * gridSize) {
    return true;
  } else {
    return false;
  }
}

bit isWithinBoundsObject(int gridSize, Particle object) {
  Cell[ARR_BND] cells = renderObj(object);
  Cell cell;
  for (int cellIndex = 0; cellIndex < ARR_BND; cellIndex++) {
    cell = cells[cellIndex];
    if (cell == null) {
      return true;
    }
    if (!isWithinBoundsPosition(gridSize, cell.position)) {
      return false;
    }
  }  
  return true;
}

// clicked
bit clickedObj(Click click, Particle object) {
  Cell[ARR_BND] cells = renderObj(object);
  Cell cell;
  for (int cellIndex = 0; cellIndex < ARR_BND; cellIndex++ ) {
    if (cell == null) {
      return false;
    }

    if (clickedPosition(click, cell.position)) {
      return true;
    }
  }
  return false;
}

bit clickedObjArray(Click click, Particle[ARR_BND] objects) {
  Particle object;
  Cell cell;
  for (int objectIndex = 0; objectIndex < ARR_BND; objectIndex++) {
    object = objects[objectIndex];
    if (object == null) {
      return false;
    }

    if (clickedObj(click, object)) {
      return true;
    } 
  }
  return false;
}

bit clickedPosition(Click click, Position position) {
  return (position.x == click.position.x) && (position.y == click.position.y);
}

// intersects NEW

bit intersectsObjObj(Particle object1, Particle object2) {
  Cell[ARR_BND] cells1 = renderObj(object1);
  Cell[ARR_BND] cells2 = renderObj(object2);
  Cell cell1;
  Cell cell2;
  for (int i = 0; i < ARR_BND; i++) {
    cell1 = cells1[i];
    for (int j = 0; j < ARR_BND; j++) {
      cell2 = cells2[j];
      if (cell1 != null && cell2 != null) {
        if (cell1.position.x == cell2.position.x && cell1.position.y == cell2.position.y) {
          return true;
        }
      }
    }
  }
  return false;
}

bit intersectsObjObjArray(Particle object, Particle[ARR_BND] objects) {
  for (int i = 0; i < ARR_BND; i++) {
    Particle object2 = objects[i];
    if (intersectsObjObj(object, object2)) {
      return true;
    }
  }
  return false;   
}


bit intersectsObjArrays(Particle[ARR_BND] objects1, Particle[ARR_BND] objects2) {
  for (int i = 0; i < ARR_BND; i++) {
    Particle object1 = objects1[i];
    if (intersectsObjObjArray(object1, objects2)) {
      return true;
    }
  }
  return false;
}

bit intersectsScene(Scene scene, Particle object) {
  Particle[ARR_BND] objects = scene.objects;
  return intersectsObjObjArray(object, objects);
}

// add/remove/update objects 
Particle[ARR_BND] addObj(Particle[ARR_BND] objects, Particle object) {
  Particle[ARR_BND] newObjects = objects;
  for (int i = 0; i < ARR_BND; i++) {
    if (newObjects[i] == null) {
      newObjects[i] = object;
      return newObjects;
    }
  }
  return newObjects;
}

Particle[ARR_BND] addObjs(Particle[ARR_BND] objects1, Particle[ARR_BND] objects2) {
  Particle[ARR_BND] newObjects = objects1;
  for (int i = 0; i < ARR_BND; i++) {
    if (newObjects[i] == null) {
      newObjects[i::(ARR_BND - i)] = objects2[0::(ARR_BND - i)];
    }
  }
  return newObjects;
}

Particle[ARR_BND] removeObjFromArray(Particle[ARR_BND] objects, Particle object) {
  Particle[ARR_BND] newObjects;
  int objectIndex = ARR_BND;
  for (int i = 0; i < ARR_BND; i++) {
    if (objects[i] == object) {
      objectIndex = i;
    }
    if (i >= objectIndex) {
      if (i == ARR_BND - 1) {
        newObjects[i] = null;
      } else {
        newObjects[i] = objects[i + 1];
      }
    } else {
      newObjects[i] = objects[i];
    }
  }
  return newObjects;
}

// NEW
Particle[ARR_BND] removeObjsFromArray(Particle[ARR_BND] objects, fun mapFn) {
  Particle[ARR_BND] newObjects;
  int newIndex = 0;
  for (int i = 0; i < ARR_BND; i++) {
    Particle object = objects[i];
    if (!mapFn(objects[i])) {
      newObjects[newIndex++] = object;
    }
  }
  return newObjects;
}

// NEW
Particle removeObj(Particle object) {
  object.alive = false;
  return object;
}

// ??? Particle updateObj(Object object, char[STR_BND] field, value) {}

Particle[ARR_BND] updateObjArray(Particle[ARR_BND] objects, fun map_fn) {
  Particle[ARR_BND] newObjects;
  for (int i = 0; i < ARR_BND; i++) {
    if (objects[i] != null) {
      newObjects[i] = map_fn(objects[i]);
    } else {
      newObjects[i] = objects[i];
    }
  }
  return newObjects;
}


// adjacent positions
Position[ARR_BND] adjPositions(int gridSize, Position position) {
  int x = position.x;
  int y = position.y;
  Position[4] positions = { new Position(x=x+1, y=y),
                            new Position(x=x-1, y=y),
                            new Position(x=x, y=y-1),
                            new Position(x=x, y=y+1) };

  Position[4] retVal;
  int retIndex = 0;
  
  for (int i = 0; i < 4; i++) {
    if (isWithinBoundsPosition(gridSize, positions[i])) {
      retVal[retIndex++] = positions[i];
    }
  }
  return retVal;
}

// NEW (ALL BELOW)

// is free functions

bit isFreePosition(Scene scene, Position position) {
  Particle[ARR_BND] objects = scene.objects;
  Particle object;
  for (int i = 0; i < ARR_BND; i++) {
    object = objects[i];
    if (object != null) {
      if (object.origin.x == position.x && object.origin.y == position.y) {
        return false;
      }
    }
  }
  return true;
}

bit isFreeClick(Scene scene, Click click) {
  return isFreePosition(scene, click.position);
}

// unitVector

Position unitVector(Position position1, Position position2) {
  int deltaX = position2.x - position1.x;
  int deltaY = position2.y - position1.y;
  if (abs(sign(deltaX)) == 1 && abs(sign(deltaY)) == 1) {
    return new Position(x=1, y=0);
  } else {
    return new Position(x=sign(deltaX), y=sign(deltaY));
  }
}

int sign(int num) {
  if (num > 0) {
    return 1;
  } else {
    if (num < 0) {
      return -1;
    } else {
      return 0;
    }
  }
}

int abs(int num) {
  if (num > 0) {
    return num;
  } else {
    return -num;
  }
}


// displacement
Position displacement(Position position1, Position position2) {
  return new Position(x=position2.x - position1.x, y=position2.y - position1.y);
}

// adjacent
bit adjacentPositions(Position position1, Position position2) {
  int deltaX = position2.x - position1.x;
  int deltaY = position2.y - position1.y;
  if (abs(deltaX) == 1 && deltaY == 0) {
    return true;
  } else {
    if (abs(deltaY) == 1 && deltaX == 0) {
      return true;
    } else {
      return false;
    }
  }
}

/*
bit adjacentObjects(Particle object1, Particle object2) {
  
}

// rotate
Position rotatePosition(Position position) {
  return new Position(x=-position.y, y=position.x);
}

Particle rotateObject(Particle object) {

}

Particle rotateNoCollision(Particle object) {

}

// move
Particle moveObject(Particle object, Position position) {

}

Particle moveNoCollision(Particle object, Position position) {

}

Position movePosition(Position position1, Position position2) {

}
*/